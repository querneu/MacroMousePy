# Gravador de Macro de Mouse

Este projeto √© uma aplica√ß√£o de interface gr√°fica (GUI) desenvolvida em Python para gravar e reproduzir macros de mouse. A ferramenta √© ideal para automatizar tarefas repetitivas no computador.

## 1. Funcionalidades

*   **Interface Gr√°fica Intuitiva**: Uma janela principal com acesso r√°pido a todas as fun√ß√µes.
*   **Grava√ß√£o de A√ß√µes**: Captura movimentos, cliques (bot√µes esquerdo, direito e do meio) e rolagens do mouse.
*   **Salvamento de Macros**: Salva as grava√ß√µes em arquivos `.json` em um diret√≥rio `macros/`, com nomes que incluem data e hora para f√°cil identifica√ß√£o.
*   **Reprodu√ß√£o Flex√≠vel**:
    *   Permite selecionar qualquer macro `.json` salva para reprodu√ß√£o.
    *   Oferece a op√ß√£o de definir um n√∫mero espec√≠fico de repeti√ß√µes.
    *   Inclui um modo de **repeti√ß√£o infinita** (loop at√© ser interrompido).
*   **Controle por Atalhos**:
    *   **`F8`**: Para a grava√ß√£o a qualquer momento.
    *   **`F9`**: Aborta a reprodu√ß√£o da macro, mesmo em loop infinito.
*   **Feedback Visual**:
    *   Uma pequena janela "marca d'√°gua" indica que a grava√ß√£o est√° ativa.
    *   Caixas de di√°logo informam sobre o status das opera√ß√µes (grava√ß√£o salva, reprodu√ß√£o finalizada, etc.).

## 2. Como Usar

1.  Execute o arquivo `main.py` ou o execut√°vel `MacroMouse.exe`.
2.  A janela principal ser√° exibida com as op√ß√µes.

### Grava√ß√£o

1.  Clique no bot√£o **"Gravar Macro"**.
2.  A janela principal desaparecer√° e um indicador "üî¥ Gravando..." aparecer√° no canto inferior direito da tela.
3.  Realize as a√ß√µes de mouse que deseja gravar.
4.  Pressione a tecla **`F8`** para parar a grava√ß√£o.
5.  Uma janela para salvar o arquivo ser√° exibida. Escolha um nome e salve a macro.
6.  A janela principal retornar√°.

### Reprodu√ß√£o

1.  Clique no bot√£o **"Reproduzir Macro"**.
2.  Selecione o arquivo `.json` da macro que deseja executar.
3.  Uma caixa de di√°logo perguntar√° quantas vezes a macro deve ser repetida.
   *   Digite um n√∫mero (ex: `5`) para um n√∫mero fixo de repeti√ß√µes.
   *   Digite `0` para repetir infinitamente.
4.  A janela principal desaparecer√° durante a reprodu√ß√£o.
5.  Para interromper a reprodu√ß√£o a qualquer momento, pressione a tecla **`F9`**.
6.  Ao final, a janela principal retornar√°.

## 3. Estrutura do C√≥digo

O c√≥digo √© organizado nas seguintes se√ß√µes:

1.  **Importa√ß√µes e Vari√°veis Globais**: M√≥dulos e vari√°veis de controle de estado.
2.  **Fun√ß√µes Utilit√°rias**: Fun√ß√µes de ajuda, como a que define o caminho para salvar arquivos.
3.  **L√≥gica de Grava√ß√£o**: Fun√ß√µes que capturam os eventos do mouse e teclado.
4.  **L√≥gica de Reprodu√ß√£o**: Fun√ß√£o que executa as a√ß√µes da macro.
5.  **Classe da Aplica√ß√£o (`MacroApp`)**: Onde a GUI e a l√≥gica de intera√ß√£o s√£o constru√≠das.
6.  **Ponto de Entrada**: Bloco que inicia a aplica√ß√£o.

## 4. An√°lise Detalhada do C√≥digo

Esta se√ß√£o detalha o funcionamento de cada parte do script.

### 4.1. Importa√ß√µes e Vari√°veis Globais

```python
from pynput import mouse, keyboard
import time
import json
import threading
import os
import sys
import tkinter as tk
from tkinter import simpledialog, messagebox, filedialog

# --- Vari√°veis Globais de Controle ---
actions = []
recording = False
playing = False
stop_thread = threading.Event()
```

*   **`pynput`**: Biblioteca principal para monitorar e controlar o mouse e o teclado.
*   **`threading`**: Essencial para executar a grava√ß√£o e a reprodu√ß√£o em threads separadas, evitando que a interface gr√°fica (Tkinter) congele.
*   **`tkinter`**: Biblioteca padr√£o do Python para a cria√ß√£o da GUI.
*   **Vari√°veis Globais**: `recording` e `playing` s√£o flags que controlam o estado da aplica√ß√£o. `stop_thread` √© um `threading.Event` usado para sinalizar de forma segura a interrup√ß√£o da thread de reprodu√ß√£o.

### 4.2. Fun√ß√µes Utilit√°rias

```python
def data_path(filename):
    """Retorna caminho absoluto, mesmo quando empacotado com PyInstaller"""
    # ...
    macros_dir = os.path.join(base, "macros")
    os.makedirs(macros_dir, exist_ok=True)
    return os.path.join(macros_dir, filename)
```

*   Esta fun√ß√£o cria um caminho seguro para os arquivos de macro, garantindo que funcione tanto ao rodar o script `.py` quanto o execut√°vel `.exe`. Ela cria um subdiret√≥rio `macros/` para manter os arquivos organizados.

### 4.3. L√≥gica de Grava√ß√£o e Atalhos

```python
def on_move(x, y):
    if recording:
        actions.append({"type": "move", "pos": (x, y), "time": time.time()})

# ... (on_click, on_scroll) ...

def on_key_press(key):
    """Listener de teclado para F8 (parar) e F9 (abortar)"""
    if key == keyboard.Key.f8 and recording:
        stop_recording_or_playing()
        return False # Para o listener de grava√ß√£o
    if key == keyboard.Key.f9 and playing:
        stop_recording_or_playing()
        return False # Para o listener de reprodu√ß√£o
```

*   As fun√ß√µes `on_move`, `on_click` e `on_scroll` s√£o "callbacks" que o `pynput` chama. Elas registram cada a√ß√£o do mouse em uma lista (`actions`) com detalhes como tipo, posi√ß√£o e o tempo exato do evento.
*   A fun√ß√£o `on_key_press` escuta as teclas `F8` (para parar a grava√ß√£o) e `F9` (para abortar a reprodu√ß√£o). Retornar `False` interrompe o listener do teclado.

### 4.4. L√≥gica de Reprodu√ß√£o

```python
def play_macro_thread(file_path, loop_count):
    # ...
    while playing and (is_infinite or loops_done < loop_count):
        prev_time = recorded[0]["time"]
        for action in recorded:
            if not playing:
                break

            delay = action["time"] - prev_time
            time.sleep(delay)
            prev_time = action["time"]
            # ... (executa a a√ß√£o: move, click, scroll) ...
```

*   A reprodu√ß√£o √© executada em uma thread (`play_macro_thread`) para n√£o travar a interface.
*   O `delay` entre as a√ß√µes √© calculado pela diferen√ßa de tempo registrada na grava√ß√£o. Isso garante que a macro seja reproduzida na mesma velocidade original.
*   O loop principal verifica a flag `playing` a cada a√ß√£o, permitindo que a tecla `F9` interrompa a execu√ß√£o a qualquer momento.

### 4.5. Classe da Aplica√ß√£o Principal (`MacroApp`)

Esta classe encapsula toda a l√≥gica da interface gr√°fica e a intera√ß√£o com o usu√°rio.

*   **`__init__(self, root)`**: Configura a janela principal, seu t√≠tulo, tamanho e chama a cria√ß√£o dos widgets.
*   **`create_main_widgets(self)`**: Cria os bot√µes "Gravar Macro", "Reproduzir Macro" e "Sair", associando cada um √† sua fun√ß√£o correspondente.
*   **`start_recording(self)`**:
    1.  Esconde a janela principal (`self.root.withdraw()`).
    2.  Mostra o indicador de grava√ß√£o.
    3.  Inicia os listeners de mouse e teclado em threads.
    4.  Usa `self.root.after()` para verificar periodicamente o fim da grava√ß√£o sem bloquear a UI.
*   **`check_recording_status(self, ...)`**: Quando a grava√ß√£o √© parada (pelo F8), esta fun√ß√£o para os listeners, fecha o indicador e chama `save_macro()`.
*   **`save_macro(self)`**:
    1.  Abre um di√°logo para o usu√°rio nomear e salvar o arquivo `.json`.
    2.  Salva a lista de a√ß√µes no arquivo.
    3.  Reexibe a janela principal (`self.root.deiconify()`).
*   **`start_playback(self)`**:
    1.  Abre di√°logos para o usu√°rio selecionar o arquivo e o n√∫mero de repeti√ß√µes.
    2.  Esconde a janela principal.
    3.  Inicia `play_macro_thread` em uma nova thread.
    4.  Usa `self.root.after()` para verificar o fim da reprodu√ß√£o.
*   **`check_playback_status(self, ...)`**: Quando a thread de reprodu√ß√£o termina, reexibe a janela principal.

### 4.6. Ponto de Entrada

```python
if __name__ == "__main__":
    main_root = tk.Tk()
    app = MacroApp(main_root)
    main_root.mainloop()
```

*   Este bloco padr√£o inicia a aplica√ß√£o. Ele cria a janela raiz do Tkinter, instancia a nossa classe `MacroApp` e inicia o loop de eventos da GUI com `main_root.mainloop()`.

## 5. Depend√™ncias

Para executar este projeto, voc√™ precisa da seguinte biblioteca:

*   **pynput**: Para controle de mouse e teclado.

Voc√™ pode instal√°-la usando pip:

```bash
pip install pynput
```

## 6. Como Empacotar (PyInstaller)

Para criar um arquivo execut√°vel (`.exe`) que pode ser distribu√≠do e executado sem a necessidade de ter o Python instalado, voc√™ pode usar o PyInstaller.

1.  **Instale o PyInstaller**:
    ```bash
    pip install pyinstaller
    ```

2.  **Execute o comando**: Navegue at√© o diret√≥rio do projeto no terminal e execute o seguinte comando. A op√ß√£o `--noconsole` (ou `--windowed`) √© importante para que a aplica√ß√£o GUI n√£o abra um terminal preto em segundo plano.

    ```bash
    pyinstaller --onefile --windowed --name MacroMouse main.py
    ```

3.  **Encontre o execut√°vel**: O arquivo `MacroMouse.exe` estar√° dentro da pasta `dist/` que ser√° criada.

---

